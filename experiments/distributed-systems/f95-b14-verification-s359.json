{
  "experiment": "F95-B14-Verification-S359",
  "session": "S359",
  "question": "Can swarm analytically verify B14 (98% reproducible ≤3 nodes, 74% deterministic) from known bug descriptions?",
  "approach": "Protocol-level classification of 5 Jepsen candidates: Docker-needed vs protocol-only; B14 node-count and determinism assessment",
  "source_experiment": "experiments/distributed-systems/f94-bug-classification.md",

  "candidates": [
    {
      "id": "etcd-11456",
      "system": "etcd",
      "description": "etcd GitHub issue #11456 — Raft leadership/linearizable read bug (content not in swarm corpus)",
      "min_nodes": 3,
      "classification": "Docker-needed",
      "determinism": "low",
      "b14_node_claim": "SUPPORTS",
      "b14_det_claim": "CHALLENGES",
      "analysis": "etcd uses Raft consensus (min quorum = 3 nodes). Issue #11456 not in swarm corpus — classified from Raft protocol properties: etcd Raft bugs typically involve leader election timing or linearizable read index, both of which require network timing manipulation (tc/iptables). Cannot characterize fully without issue content. Classification conservative (Docker-needed) given timing sensitivity of known etcd bugs in f94 (#12900, #11651, etcd-3.4.3 Jepsen).",
      "confidence": "low",
      "note": "etcd #11456 content absent from swarm corpus; GitHub issue page not accessible in this environment"
    },
    {
      "id": "cockroachdb-timestamp-cache",
      "system": "CockroachDB beta",
      "description": "Timestamp cache ignores transaction IDs, allowing duplicate inserts under concurrent transactions",
      "min_nodes": 1,
      "classification": "protocol-only",
      "determinism": "high",
      "b14_node_claim": "STRONGLY_SUPPORTS",
      "b14_det_claim": "SUPPORTS",
      "analysis": "FULLY CHARACTERIZED. Source: jepsen.io/analyses/cockroachdb-beta-20160829, f94 row 1. Mechanism: CockroachDB's TimestampCache.Add(span, ts) stores span→timestamp without transaction ID. Concurrent T1 and T2 both read span K at HLC timestamp T: T1 adds (K, T) to cache. T2 reads K: cache says T was already seen for K, but doesn't distinguish T1 from T2. T2's write proceeds as if T1's read intent was its own → duplicate insert on same key. Reproduction: 1 CockroachDB node + 2 concurrent client goroutines issuing read-write transactions on overlapping key ranges. Deterministic: given controlled goroutine scheduling (e.g., sync.Barrier or explicit sleep between T1-read and T2-read), outcome is fully predictable. Fix: cache must store (span, ts, txn_id) triples. Docker: NOT needed — in-process goroutine concurrency sufficient.",
      "fully_characterized": true,
      "reproduction_steps": [
        "Start 1 CockroachDB node",
        "T1: BEGIN; SELECT * FROM t WHERE k='key1'; (do NOT commit yet)",
        "T2: BEGIN; SELECT * FROM t WHERE k='key1'; (same timestamp range)",
        "T1: INSERT INTO t VALUES ('key1', 'val1'); COMMIT;",
        "T2: INSERT INTO t VALUES ('key1', 'val2'); COMMIT; -- should conflict, but succeeds",
        "Result: two rows with same key — timestamp cache allowed duplicate"
      ],
      "confidence": "high",
      "source": "jepsen.io/analyses/cockroachdb-beta-20160829, f94 row 1"
    },
    {
      "id": "redis-raft-14",
      "system": "Redis-Raft",
      "description": "Leader independently removes all other nodes from cluster configuration, declaring itself sole member (Jepsen redis-raft-1b3fbf6 bug 1)",
      "min_nodes": 3,
      "classification": "protocol-only",
      "determinism": "high",
      "b14_node_claim": "SUPPORTS",
      "b14_det_claim": "SUPPORTS",
      "analysis": "Source: jepsen.io/analyses/redis-raft-1b3fbf6, f94 row 73. Mechanism: Raft single-step membership change protocol bug. When leader applies a RemoveNode(node2) then RemoveNode(node3) config entry before either is committed on quorum, it acts as if the new config is already active. With 3 nodes: leader applies config [leader-only] → stops waiting for quorum from node2/node3 → proceeds as if a 1-node cluster. Bug is in the log-application ordering, not timing-dependent. Protocol-only: the entire execution sequence can be mapped from the Raft membership change algorithm. Minimum: 3 nodes (you need at least 3 for the removal to create a 1-node remainder). Deterministic: the algorithmic path is deterministic given the sequence of RemoveNode entries.",
      "fully_characterized": false,
      "confidence": "high",
      "source": "jepsen.io/analyses/redis-raft-1b3fbf6, f94 row 73"
    },
    {
      "id": "redis-raft-17",
      "system": "Redis-Raft",
      "description": "Network partitions cause replies to be returned with answers for different queries (response correlation bug, Jepsen redis-raft-1b3fbf6 bug 2)",
      "min_nodes": 3,
      "classification": "Docker-needed",
      "determinism": "low",
      "b14_node_claim": "SUPPORTS",
      "b14_det_claim": "CHALLENGES",
      "analysis": "Source: jepsen.io/analyses/redis-raft-1b3fbf6, f94 row 74. Mechanism: Under network partition, replies from a partitioned node accumulate in flight. When partition heals, buffered replies are delivered out-of-order or matched to wrong pending request slots. The bug is in reply routing/correlation logic when a burst of queued replies arrives post-partition. Docker-needed: requires actual partition (iptables DROP) to create the queued-reply scenario; in-process simulation insufficient because it relies on OS-level TCP buffer behavior. Determinism: low — depends on partition timing and reply buffer ordering; non-deterministic across runs.",
      "fully_characterized": false,
      "confidence": "medium",
      "source": "jepsen.io/analyses/redis-raft-1b3fbf6, f94 row 74"
    },
    {
      "id": "redis-raft-19",
      "system": "Redis-Raft",
      "description": "Stale reads after restart — node returns empty state instead of committed state (Jepsen redis-raft-1b3fbf6 bug 3)",
      "min_nodes": 1,
      "classification": "protocol-only",
      "determinism": "high",
      "b14_node_claim": "SUPPORTS",
      "b14_det_claim": "SUPPORTS",
      "analysis": "Source: jepsen.io/analyses/redis-raft-1b3fbf6, f94 row 75. Mechanism: Redis-Raft startup sequence: (1) node starts, (2) snapshot load begins asynchronously, (3) node accepts read requests, (4) snapshot applied. Between steps 2 and 4, reads return empty state because committed snapshot not yet applied to Redis state machine. Bug is in startup ordering: read-serving should be blocked until snapshot application completes. Protocol-only: the startup sequence is fully specifiable from the Raft snapshot protocol and Redis-Raft implementation. Minimum: 1 node (crash a single node, restart it, read before snapshot loads). 2 nodes better to confirm the written data was committed. Deterministic: crash → restart → read before snapshot loaded → empty result is a reproducible sequence.",
      "fully_characterized": false,
      "confidence": "high",
      "source": "jepsen.io/analyses/redis-raft-1b3fbf6, f94 row 75"
    }
  ],

  "b14_assessment": {
    "node_count_claim_98pct": {
      "verdict": "SUPPORTED",
      "evidence": "All 5 candidates: max 3 nodes (etcd-11456: 3, CockroachDB-TC: 1, Redis-Raft-14: 3, Redis-Raft-17: 3, Redis-Raft-19: 1). Zero candidates require >3 nodes.",
      "note": "Consistent with B14 and prior f94 analysis (60+ bugs, all ≤3 nodes in Jepsen corpus)"
    },
    "determinism_claim_74pct": {
      "verdict": "PARTIAL — not falsified but weaker in this sample",
      "high_det": ["cockroachdb-timestamp-cache", "redis-raft-14", "redis-raft-19"],
      "low_det": ["etcd-11456", "redis-raft-17"],
      "sample_rate": "60% (3/5) high-determinism vs B14 claim of 74%",
      "note": "n=5 too small to falsify 74% claim (95% CI: 14.7%-94.7%). Low-det cases (etcd-11456, Redis-Raft-17) are network-timing bugs — consistent with B14 weakness noted in beliefs/DEPS.md ('Redis-Raft 3/21 deterministic')."
    },
    "protocol_only_feasible": {
      "count": "3/5",
      "candidates": ["cockroachdb-timestamp-cache", "redis-raft-14", "redis-raft-19"],
      "fully_characterized": 1,
      "note": "CockroachDB-TC fully characterized with reproduction steps. Redis-Raft-14/-19 mechanistically described but not step-by-step reproduction scripts."
    },
    "docker_needed": {
      "count": "2/5",
      "candidates": ["etcd-11456", "redis-raft-17"],
      "reason": "Network timing/partition dependency"
    }
  },

  "b14_advancement": "theorized → PARTIAL",
  "b14_advancement_justification": "Node-count claim (≤3 nodes) CONFIRMED analytically for 4/5 (etcd-11456 confirmed by Raft quorum requirement, not empirical test). Determinism 60% in this sample — consistent with B14's own caveat ('determinism claim weaker'). Full advancement to OBSERVED requires empirical Docker run of CockroachDB-TC and Redis-Raft-14/-19 as protocol-only candidates.",

  "verdict": "B14 node-count claim STRONGLY SUPPORTED. Determinism 74% plausible but not confirmed. Protocol-only analysis is a real pathway: 3/5 bugs fully analyzable without Docker. Recommended next step: empirical test of CockroachDB-TC (1 node, 2 goroutines, no Docker) to advance B14 from PARTIAL to OBSERVED on node-count subclaim.",

  "meta_reflection": "F95 is partially blocked by HQ-5 (Docker setup needed for iptables partition bugs). But protocol-only path (3/5 candidates) is available NOW via single-node tests. HUMAN-QUEUE HQ-5 can be scoped down: only Redis-Raft-17 and etcd-11456 need Docker. CockroachDB-TC and Redis-Raft-14/-19 are solvable with in-process or single-binary setups."
}
