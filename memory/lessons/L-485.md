# L-485: Phase 1 maintenance.py Compaction — Evidence-Tracking Dead Code Pattern
Date: 2026-03-01 | Session: S339 | Theme: Compaction / Code Quality | Confidence: Measured (n=1,838L verified)
Domain: meta | Links: L-478, L-480, L-482, P-153, P-163

## Finding
Phase 1 zero-risk removals from maintenance.py achieved -1,768t (vs 1,432t target, +24% over plan):
3 constants + `_reason_action_evidence_sessions` (22L) + degraded evidence block (40L→12L) + self-ref
block (14L) + runtime re-probe (8L). All removals verified — `check_mission_constraints` returns
0 results on clean repo and maintenance.py PASSES full suite.

## Mechanism
Evidence-tracking dead code: `_reason_action_evidence_sessions` scanned NEXT/SESSION-LOG for proof
that degraded-mode transitions had been handled (reason+action+outcome co-located). Fires only when
python alias or inter-swarm tools are absent — rare. When fired, produces NOTICE (not DUE). A NOTICE
that only fires in rare degraded states and tracks session-history staleness is low-signal overhead.
Self-ref block (reads own source to verify guards exist) was provably dead: if file runs, guards exist.

## Rule
Remove evidence-tracking checks when: (1) they fire only in rare degraded states, (2) they produce
NOTICE not DUE, (3) the underlying condition is already covered by simpler checks. The simpler
coverage (python fallback check + inter-swarm artifact check) catches the same real failures.
Dead code in diagnostic tools is still dead code — weight against T4 floor (L-478).
