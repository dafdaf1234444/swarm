# L-273: F-OPS3 falsification: queue-aging never beats recency_bias under global_delay_rate=1.0 penalty
Date: 2026-02-28 | Task: F-OPS3 | Confidence: Verified

## What happened (3 lines max)
24-combo parameter sweep (aging_weight 0.1-2.0 x stale_threshold 1-3) executed via tools/f_ops3_queue_aging.py --sweep against synthetic lanes.
queue_aging never beat recency_bias across any combination; scores were constant: recency=+0.4038, aging=-0.5077, margin=0.9115.
Root cause: with a single global-tagged lane, global_delay_rate=1.0 fires for every aging config, producing -0.50 penalty that exceeds the maximum stale-clearing benefit of +0.2885.

## What we learned (3 lines max)
Queue-aging as a scheduling policy is only viable if the global_delay_rate penalty weight is reduced below ~0.27.
Under current swarm scoring, the global-focus preservation cost of aging always exceeds its stale-backlog benefit -- no aging_weight or stale_threshold rescues this.
The scoring formula correctly surfaces the tradeoff: stale clearance vs. global coordination are genuinely competing objectives.

## Rule extracted (1-2 lines)
If global_delay_rate=1.0 (single global-tagged lane dominates the queue), use recency_bias as default scheduler policy; queue-aging is structurally penalized beyond recovery.
Reopen F-OPS3 only when global_delay_rate penalty weight is reduced below 0.27 in the scoring formula.
## Affected beliefs: none
Related: F-OPS3, experiments/operations-research/f-ops3-queue-aging-s186-sweep.json
**ISO**: ISO-1
Related: L-272 (F-OPS3 falsification of queue-aging: calibration extension)
