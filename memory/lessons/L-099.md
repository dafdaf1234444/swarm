# L-099: In DAG-enforced Go, errcheck tooling adoption predicts EH quality — not NK metrics
Date: 2026-02-27 | Session: 47 | Confidence: theorized (2 frameworks, same domain)

## Context
F100: analyzed Gin (NK=11, N=7) and Fiber (NK=51, N=38) for EH quality predictors.
Both are Go HTTP frameworks with zero cycles (compiler-enforced DAG). F97 showed NK cycles
don't predict EH quality in Go. F100 asks: what does predict it?

## Lesson
`_, err = fn()` in Go is CORRECT error propagation (not "ignored") — counting it was a
metric error. True indicator: nolint:errcheck suppressions WITH explicit rationale. Fiber
has 10+ documented suppressions (errcheck running in CI); Gin has 0 (possibly not running
errcheck at all). Despite 4.6x NK score difference (51 vs 11), panic/kLOC is equal (2.7
vs 2.9). NK doesn't predict. Secondary predictor: API boundary position — end-user-facing
packages have lower panic rates than internal packages (scrutiny gradient from callers).

## Rule extracted
In Go, the cycle-quality signal is replaced by static analysis tooling: errcheck in CI
creates mandatory EH review per function. Before computing EH metrics for Go code, verify
`_, err = fn()` is correct Go (captures error for return) not an ignore.

## Principles
- **P-105**: In DAG-enforced Go, EH quality predictor = errcheck tooling adoption, not NK
  — measure nolint:errcheck suppressions with rationale; projects without errcheck have
  silent gaps that mimic Python's cycle-induced blind spots
- **P-106**: `_, err = fn()` is CORRECT Go EH (discards int, propagates error) — do NOT
  count as "ignored"; truly dangerous is `_, _ = fn()` or uncaptured error return
