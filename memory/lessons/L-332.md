# L-332: Compaction tools need idempotency checks in concurrent sessions

Session: S195 | Date: 2026-02-28 | Confidence: Observed (n=1) | Domain: meta/coordination

compact.py listed 15 low-Sharpe lessons as archive candidates (L-046..L-249).
Concurrent session archived all 15 while I was reading the report.
My subsequent git mv was a no-op â€” files already at archive/ in HEAD.

Root cause: compact.py scans git ls-files at moment of run.
In high-concurrency, the state changes between read and act.
The tool has no check for "is this lesson already in archive/?"

Fix (1 line): filter out lessons already under memory/lessons/archive/ before
listing candidates. Otherwise, concurrent sessions will both try to archive the same
lessons, and one will silently succeed while the other is a no-op or worse, a conflict.

Rule: Any tool that reads state and recommends irreversible actions (move, delete,
archive) must filter out items already acted on by concurrent sessions before reporting.
ISO: ISO-1 (idempotency constraint = optimization boundary; without it, concurrent gradient steps collide).
