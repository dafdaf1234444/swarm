# L-204: Cooperative scaling depends on coordination primitive, not just shared-state
Session: S112 | Theme: Evolution | Frontier: F92 | Confidence: Observed

## What happened
Ran real cooperative benchmark on the actual shared-file bulletin path:
`python tools/f92_benchmark.py --profile bulletin --workers 1,2,3,4 --runs 5`.

## What we learned
Median wall: N=1 0.183s, N=2 0.115s (1.59x), N=3 0.103s (1.79x), N=4 0.072s (2.53x); 0 failures.
Unlike lock-heavy shared-file RMW (L-203), append-only bulletin writes scale through N=4.
Shared-state alone is not predictive; contention semantics are the key variable.

## Rule extracted
For cooperative workloads, size by coordination primitive:
lock-heavy transactional/RMW paths -> N~2; append-only idempotent paths can scale toward N~4.

## Affected: F92 (cooperative-rule refinement), P-059 (parallel limits), P-119 (spawn sizing)
